<htmL>

<head>
    <meta charset="UTF-8">
    <title>Impaired Driving Death Rate by Age, Gender, and State</title>
    <script type="text/javascript" src="libraries/d3.js"></script>
    <!-- <script src="//d3js.org/d3.v4.min.js"></script> -->
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <script type="text/javascript" src="libraries/d3-legend-2.24.0/d3-legend.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">


    <!-- removes any default padding and style -->
    <style>
        body {
            padding: 0;
            margin: 0;
        }

        h1 {
            font-family: FontAwesome;
            font-size: 1em;
            color: #333;
        }

        .title {
            position: absolute;
            top: 0px;
            left: 170px;
            font-family: FontAwesome;
            font-size: 2em;
            color: #333;
        }

        .background {
            fill: none;
            pointer-events: all;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
        }

        .states {
            fill: #e5e5e5;
            stroke: #fff;
            stroke-width: 2px;
            cursor: pointer;
        }

        .states:hover {
            fill: steelblue;
        }
        /*
        .states.active {
            transition: transform 1s linear;
            transform: translateY(300px) rotateX(70deg);
        }
        */
        /* slider styling */

        .track {
            stroke: #000;
            stroke-opacity: 0.3;
            stroke-width: 10px;
        }

        .track-inset {
            stroke: #ddd;
            stroke-width: 8px;
        }

        .track-overlay {
            pointer-events: stroke;
            stroke-width: 50px;
            cursor: crosshair;
        }

        .handle {
            fill: #fff;
            stroke: #000;
            stroke-opacity: 0.5;
            stroke-width: 1.25px;
        }
        /* Bar Chart */

        .bar {
            box-shadow: -2px 5px 5px #999;
        }

        .axis {
            font: 10px arial;
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }
    </style>
</head>

<body>
    <div class="title">
        Impaired Driving Death Rate for 2012 and 2014
    </div>


    <div id="info">
        <h1 id="name"></h1>
    </div>
    <script>
        /* Final d3 Assignment
		* Peter Thung, Daniel Vance
        * Sources:
        *   Map Data -> http://bl.ocks.org/mapsam/6083585
        *   Impaired driving data -> https://www.cdc.gov/motorvehiclesafety/impaired_driving/states-data-tables.html
        *   Added fill color to choropleth map, based on % driving death rate.
        *   Zoom transition -> https://bl.ocks.org/mbostock/4699541
        *   Added threshold legend utilzing http://d3-legend.susielu.com/#color-threshold
        *           Note: there was an issue with .useClass(true) method, making
        *                 the squares in the legend all black.
        *   Slider for year -> http://bl.ocks.org/darrenjaworski/5397202
        *   Added code to link choropleth graph to change based on year selected.
        *   visualized death rates for age groups as well as gender.
        *   Histogram -> http://bl.ocks.org/jensgrubert/7777399
        *   added legend key state selection fill/unfill
        *   Added initial transition of States to assemble like jig saw puzzle from random points away from center upon refersh of page.
        *   Added button for year selection, initialzing 2012 button selected upon initial page load. (Note need to remove yearSlider)
        *   Removed the year Slider bar and slipped in the year buttons in it's place.
		*/
        var w = 960,
            h = 700,
            active = d3.select(null),
            deathRateFlag = true,
            deathRateYear = 2012,
            rawDataFlag = false;

        var ageRangeSelected = "All Ages"; // e.g. All Ages, Ages 0-20, Ages 21-34, Ages 35+
        var aggDataPersisted;
        var usPersisted;
        var prevalenceDataPersisted;
        var deathRateDataPersisted;

        var yearSliderY = 585;
        var genderButtonsGroupY = 610;
        var yearButtonsGroupY = 560;
        var ageRangeSliderY = 665;
        var rawButtonsGroupY = 510;

        var threshold = (rawDataFlag ? [50, 100, 250, 500, 1000] : [1, 3, 6, 9, 11]);
        var colorRange = ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"];

        var lastFilterPath = null;

        // globals in support of legend selection
        var selectedFillOpacity = .85;
        var unSelectedFillOpacity = 1;
        var selectedFillColor = d3.color("Orange");

        // Globals in support of Buttons
        //fontawesome button labels
        var labelsGender = ['\uf183', '\uf182', '\uf0c0'];
        var labelsId = ['Male', 'Female', 'Both'];
        var labelsYear = ['2012', '2014', '2016'];
        var labelsYearId = ['a_2012', 'a_2014', 'a_2016'];
        var labelsRawData = ["Raw"];
        var labelsRawDataID = ["raw"];

        var genderSelected = labelsId[2];  // default both
        //colors for different button states
        var defaultColor = "#7777BB"
        var hoverColor = "#0000ff"
        var pressedColor = "#000077"
        var pressedColor2 = "#080077"
        var bWidth = 40; //button width
        var bHeight = 25; //button height
        var bSpace = 10; //space between buttons
        var x0 = 20; //x offset
        var y0 = 10; //y offset
        // end globals in support of buttons

        // BarChart
        var x = d3.scaleBand().domain(["Female 2012", "Male 2012", "Female 2014", "Male 2014", "Female 2016", "Male 2016"])
            .range([0, 650])
            .paddingOuter(0.1);
        var y = d3.scaleLinear();

        var xAxis = d3.axisBottom(x)
            .ticks(4);
        var yAxis = d3.axisLeft(y)
            .ticks(6);
        // End Bar Chart

        var svg = d3.select("body").append("svg")
            .attr("width", w)
            .attr("height", h)
        //  .attr("style", "border: 2px solid #aaaaaa;")

        // var title = svg.selectAll(".title").append("div")

        var margin = { right: 50, left: 50 },
            width = +svg.attr("width") - margin.left - margin.right,
            height = +svg.attr("height");

        var colorScale = d3.scaleThreshold()
            .domain(threshold) // currently needed to manually deterine domain by hand based on data.
            .range(colorRange);

        var g = svg.append("g")
            .style("stroke-width", "1.5px");

        var projection = d3.geoAlbersUsa()
            .scale(1000)
            .translate([w / 2, h / 2]);

        var path = d3.geoPath(projection);

        var geoProjection = d3.geoConicEqualArea()
            .scale(1000)
            .translate([w / 2, h / 2]);

    // Machine Learning Utility functions
    // refeerence: http://trentrichardson.com/2010/04/06/compute-linear-regressions-in-javascript/
        function linearRegression(y,x){
            var lr = {};
            var n = y.length;
            var sum_x = 0;
            var sum_y = 0;
            var sum_xy = 0;
            var sum_xx = 0;
            var sum_yy = 0;
            
            for (var i = 0; i < y.length; i++) {
                
                sum_x += x[i];
                sum_y += y[i];
                sum_xy += (x[i]*y[i]);
                sum_xx += (x[i]*x[i]);
                sum_yy += (y[i]*y[i]);
            } 
            
            lr['slope'] = (n * sum_xy - sum_x * sum_y) / (n*sum_xx - sum_x * sum_x);
            lr['intercept'] = (sum_y - lr.slope * sum_x)/n;
            lr['r2'] = Math.pow((n*sum_xy - sum_x*sum_y)/Math.sqrt((n*sum_xx-sum_x*sum_x)*(n*sum_yy-sum_y*sum_y)),2);
            lr['fn'] = function (x) { return this.slope * x + this.intercept; };
            
            return lr;
        }   

        /* For the drop shadow and blur filters
           https://stackoverflow.com/a/17373466/4897795
         */
        var defs = svg.append("defs");

        var filter = defs.append("filter")
            .attr("id", "dropshadow")

        filter.append("feGaussianBlur")
            .attr("in", "SourceAlpha")
            .attr("stdDeviation", 4)
            .attr("result", "blur");
        filter.append("feOffset")
            .attr("in", "blur")
            .attr("dx", 2)
            .attr("dy", 2)
            .attr("result", "offsetBlur")
        filter.append("feFlood")
            .attr("in", "offsetBlur")
            .attr("flood-color", "#aaa")
            .attr("flood-opacity", "0.75")
            .attr("result", "offsetColor");
        filter.append("feComposite")
            .attr("in", "offsetColor")
            .attr("in2", "offsetBlur")
            .attr("operator", "in")
            .attr("result", "offsetBlur");

        var feMerge = filter.append("feMerge");

        feMerge.append("feMergeNode")
            .attr("in", "offsetBlur")
        feMerge.append("feMergeNode")
            .attr("in", "SourceGraphic");

        var blurFilter = defs.append("filter")
            .attr("id", "blur")
            .append("feGaussianBlur")
            .attr("stdDeviation", 1.5);

        /* End filters */

        d3.csv("data/impaired-driving-prevalence-2012-all-states.csv", function (error, prevalenceData) {
            if (error) return console.warn(error);
            prevalenceDataPersisted = prevalenceData;
            d3.csv("data/impaireddrivingdeathrate.csv", function (error, deathRateData) {
                if (error) return console.warn(error);
                deathRateDataPersisted = deathRateData;
                d3.csv("data/Impaired_Driving_Death_Rate.csv", function (error, aggData) {
                    aggDataPersisted = aggData;
                    if (error) return console.warn(error);
                    regressData(aggDataPersisted);

                    d3.json("data/us.json", function (error, us) {
                        if (error) throw error;
                        usPersisted = us;

                        g.selectAll('.states')
                            .data(topojson.feature(us, us.objects.usStates).features)
                            .enter()
                            .append('path')
                            .attr("class", "states")

                            // .transition()
                            //    .attr("transform", function (d, i) {
                            //         return "translate(" + Math.random() * (-50) + "," + Math.random() * (-50) + ")" })
                            //    .duration(3000)

                            .attr('d', path)
                            .on('mouseover', function (d) {
                                svg.selectAll("incidents").remove();
                                var name = d.properties.STATE_ABBR;
                                var prevalence = getStatePrevalence(name, prevalenceData),
                                    deathRate = getStateDeathRateV2(name, "all");
                                if (!prevalence) prevalence = 0;
                                if (!deathRate) deathRate = 0;

                                var deathInfo = "Death" + (rawDataFlag ? "s: " : " Rate: ") + deathRate + (rawDataFlag ? '' : '%')
                                var stateInfo = name + ": </br>Prevalence: " + prevalence + "%</br>" + deathInfo;
                                return document.getElementById('name').innerHTML = stateInfo;
                            })
                            .attr("filter", "url(#dropshadow)")
                            .on("click", clicked)

                            .style("fill", "none")
                            .attr("transform", function (d, i) {
                                // https://stackoverflow.com/questions/8611830/javascript-random-positive-or-negative-number
                                var plusOrMinus1 = Math.random() < 0.5 ? -1 : 1;
                                var plusOrMinus2 = Math.random() < 0.5 ? -1 : 1;
                                var lh = 400;//h;
                                var lw = 400;//w;
                                return "translate(" + (plusOrMinus1 * d3.randomUniform(lh, lh + 200)()) + "," +
                                    (plusOrMinus2 * d3.randomUniform(lw, lw + 200)()) + ") rotate(" + d3.randomUniform(0, 360)() + ")"
                            })

                            .transition()
                            .style("fill", function (d) {
                                var name = d.properties.STATE_ABBR;
                                var stats;
                                if (deathRateFlag) {
                                    stats = getStateDeathRateV2(name, "All");
                                } else {
                                    stats = getStatePrevalence(name, prevalenceData);
                                }
                                var colorValue = colorScale(stats);
                                return colorScale(stats); // <-D
                            })
                            .attr("transform", function (d, i) {
                                return "translate(" + (0) + "," + (0) + ")"
                            })
                            .duration(3000)
                            // .transition()
                            //     .delay(3000)

                            ;
                        updateButtonColors(d3.select("g.button.both"), d3.select("#genderButtons"));
                    });
                });
            });
        });

        var chart = svg.append("g")
            .attr("class", "chart")
            .attr("transform", "translate(150, 550)");

        function clicked(d) {
            if (active.node() === this) {
                return reset()
            }
            active.classed("active", false);
            active = d3.select(this).classed("active", true);

            var bounds = path.bounds(d),
                dx = bounds[1][0] - bounds[0][0],
                dy = bounds[1][1] - bounds[0][1],
                x = (bounds[0][0] + bounds[1][0]) / 2,
                y = (bounds[0][1] + bounds[1][1]) / 2,
                scale = .6 / Math.max(dx / w, dy / h),
                translate = [w / 2 - scale * x, h / 2 - scale * y];

            g.transition()
                .duration(750)
                .style("stroke-width", 1.5 / scale + "px")
                .attr("transform", "translate(" + translate + ")scale(" + scale + ")")
                .attr("filter", "url(#blur)");
            g.append("rect")
                .attr("x", "0")
                .attr("y", "0")
                .attr("width", w / 20)
                .attr("height", h / 15)
                .attr("transform", "translate(" + translate + ")scale(" + scale + ")");

            newBarChart(d);
        }

        function newBarChart(data) {

            d3.selectAll(".states")
                .classed("active", true);


            chart.selectAll("g").remove()
            chart.selectAll("rect").remove();

            var tmpGender = genderSelected;
            var tmpAge = ageRangeSelected;
            var tmpYear = deathRateYear;
            var gender = ["Female", "Male"];
            var year = ["2012", "2014"];
            var results = [];
            var name;

            gender.forEach(function (g) {
                year.forEach(function (y) {
                    name = "" + g + " " + y;
                    genderSelected = g;
                    deathRateYear = y;
                    results.push({
                        "name": name,
                        "gender": g,
                        "year": y,
                        "stats": getStateDeathRateV2(data.properties.STATE_ABBR, "gender")
                    });
                });
            });

            deathRateYear = tmpYear;
            genderSelected = tmpGender;
            ageRangeSelected = tmpAge;

            var max = [];
            results.forEach(function (r) {
                max.push(r.stats);
            });

            yMax = d3.max(max);
            y.domain([0, yMax])
                .range([400, 0]);

            chart.append("g")
                .attr("class", "x axis")
                .call(xAxis)
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "2.5em");

            chart.append("g")
                .attr("class", "y axis")
                .attr("transform", "translate(0, -400)")
                .call(yAxis)
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Value ($)");

            var bar = chart.selectAll(".bar")
                .remove()
                .exit()
                .data(results)

            bar.enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", function (d) {
                    return x(d.name);
                })
                .attr("width", 100)
                .attr("y", function (d) { return y(d.stats); })
                .attr("height", function (d) { return (400 - y(d.stats)); })
                .attr("transform", "translate(20, -400)")
                .attr("stroke", "1px")
                .attr("fill", function (d) {
                    if (d.gender == "Female") {
                        return "rgb(255, 105, 100)";
                    } else {
                        return "rgb(60, 100, 255)";
                    }
                })
                .attr("filter", "url(#dropshadow)")
                .transition()
                .duration(750);
        }

        function reset() {
            chart.selectAll("g").remove();
            chart.selectAll("rect").remove();
            active.classed("active", false);

            d3.selectAll(".states")
                .classed("active", false);

            active = d3.select(null);
            g.transition()
                .duration(750)
                .style("stroke-width", "1.5px")
                .attr("transform", "")
                .attr("filter", "");

        }

        // add D3 Radio Buttons to represent Male/Female/Both selections to access those particular
        // data




        // add   Age Range
        // var x = d3.scaleLinear()
        //var yearList = [2012, 2013, 2014, 2015, 2016];  // test for greater number of years

        var ageRangeList = ["All Ages", "Ages 0-20", "Ages 21-34", "Ages 35+"];
        var sliderBarPixelDomain = [0, 600];


        var xAgeRange = d3.scaleQuantile()
            .domain(sliderBarPixelDomain)
            .range(ageRangeList);
        //.clamp(true); // does not exist for d3.scaleQuantize



        var sliderAgeRange = svg.append("g")
            .attr("class", "slider ageRange")
            .attr("transform", "translate(" + margin.left + "," + ageRangeSliderY + ")");



        sliderAgeRange.append("line")
            .attr("class", "track")
            .attr("x1", xAgeRange.domain()[0])
            .attr("x2", xAgeRange.domain()[1])
            .select(function () { return this.parentNode.appendChild(this.cloneNode(true)); })
            .attr("class", "track-inset")
            .select(function () { return this.parentNode.appendChild(this.cloneNode(true)); })
            .attr("class", "track-overlay")
            .call(d3.drag()
                .on("start.interrupt", function () { sliderAgeRange.interrupt(); })
                .on("start drag", function () {
                    ageRange(d3.event.x); // so deathRateYear is updated while it is being dragged vice on dragended.  May have effect of updating choropleth as slider is being slid, if we had more than two years.
                    updateChoropleth("ageRange");
                })
                .on("end", dragendedAgeRange)
            )
            ;



        sliderAgeRange.insert("g", ".track-overlay")
            .attr("class", "ticks")
            .attr("transform", "translate(0," + 30 + ")") // controls how many pixels below bar
            .selectAll("text")
            .data(getTickArray(xAgeRange))
            .enter().append("text")
            .attr("x", function (d) { return d; })
            .attr("text-anchor", "middle")
            .text(function (d) {
                //console.log(xYear(d));
                return xAgeRange(d);
            });



        var handleAgeRange = sliderAgeRange.insert("circle", ".track-overlay")
            .attr("class", "handle ageRange")
            .attr("r", 9);



        function ageRange(xActual) {
            // code below fixes the actual handle to snap to the tick marks
            // for ranges that
            var xExtent = xAgeRange.invertExtent(xAgeRange(xActual));
            var xExtentLeft = xExtent[0];
            var xExtentRight = xExtent[1];
            var xExtentMid = (xExtentLeft + xExtentRight) / 2;
            var xPixelLocation;
            if (xExtentRight === xAgeRange.domain()[1]) {
                handleAgeRange.attr("cx", xAgeRange.domain()[1]);
            } else if (xExtentLeft === xAgeRange.domain()[0]) {
                handleAgeRange.attr("cx", xAgeRange.domain()[0]);
            } else {
                handleAgeRange.attr("cx", xExtentMid);
            }
            ageRangeSelected = xAgeRange(xActual);
        }



        function dragendedAgeRange(d) {
            updateChoropleth("ageRange");
        }

        function updateChoropleth(filterPath) {
            unSelectAllStates(); // to prevent unintended selection of states based on new data
            // need to do this first, prior to changing states else
            // if states are selected, would be overiding previous state fill color
            // re-calculate death rate colors.
            var states = svg.selectAll('.states')
                .data(topojson.feature(usPersisted, usPersisted.objects.usStates).features);

            //not expecting less states so not expecting this to do anything
            states.exit().remove();

            // planning on skipping .enter() as not expecting any new states
            // // udpate
            states.merge(states)
                .style("fill", function (d) {
                    //console.log(d);
                    var name = d.properties.STATE_ABBR;
                    var result = aggDataPersisted.filter(function (obj) { return obj['State '] == name; });
                    var stats = getStateDeathRateV2(name, filterPath);
                    tempDeathRate = stats;
                    // ref: https://stackoverflow.com/questions/3363463/append-custom-attributes-to-a-dom-node
                    this.setAttribute('value', stats); // store copy of current calculate death stats in dom for retreival by legend code
                    var colorValue = colorScale(stats);
                    return colorScale(stats);
                })
                .on('mouseover', function (d) {
                    svg.selectAll("incidents").remove();
                    var name = d.properties.STATE_ABBR;
                    if (name === "Washington DC") {
                        name = "District of Columbia"; // fixes issue where
                    }
                    var prevalence = getStatePrevalence(name, prevalenceDataPersisted);
                    var deathRate = getStateDeathRateV2(name, filterPath);
                    if (!prevalence) prevalence = 0;
                    if (!deathRate) deathRate = 0;

                    var deathInfo = "Death" + (rawDataFlag ? "s: " : " Rate: ") + deathRate + (rawDataFlag ? '' : '%')
                    var stateInfo = name + ": </br>Prevalence: " + prevalence + "%</br>" + deathInfo;
                    return document.getElementById('name').innerHTML = stateInfo;
                })
                .on("click", clicked);




        }

        // outlineStateBasedOnDeathRateValue
        function toggleLegendState(lowerBound, upperBound, cell) {

            // console.log(bounds);


            // check for cell state
            var cellState = cell.getAttribute('selected');
            if (cellState === "true") {
                // cell is selected -> unselected
                // update legend rectange fill color to original  and cell state to false

                cell.setAttribute('selected', "false");
                var rectangle = d3.select(cell).select("rect.swatch")
                var unSelectedRectangleFillColor = rectangle.attr("originalFillColor");
                rectangle.style("fill", unSelectedRectangleFillColor);
                rectangle.style("fill-opacity", unSelectedFillOpacity);
            } else {
                // cell is unselected -> selected
                // save off original rectangle fill color
                var rectangle = d3.select(cell).select("rect.swatch")
                var currentRectangleFillColor = rectangle.style("fill");
                rectangle.attr("originalFillColor", currentRectangleFillColor);
                // update legend rectange fill color to original  and state to false
                cell.setAttribute('selected', "true");
                rectangle.style("fill", selectedFillColor);
                rectangle.style("fill-opacity", selectedFillOpacity);
            }

            // re-calculate death rate colors.
            var states = svg.selectAll('.states')
                .data(topojson.feature(usPersisted, usPersisted.objects.usStates).features);

            //not expecting less states so not expecting this to do anything
            // states.exit().remove();

            // planning on skipping .enter() as not expecting any new states
            // // udpate
            states.merge(states)
                .style("fill-opacity", function (d) {
                    //console.log(d);
                    // var name = d.properties.STATE_ABBR;
                    // var result = aggDataPersisted.filter(function (obj) { return obj['State '] == name; });
                    // var stats = getStateDeathRateV2(name, filterPath);
                    // tempDeathRate = stats;
                    // // ref: https://stackoverflow.com/questions/3363463/append-custom-attributes-to-a-dom-node
                    // this.setAttribute('value', stats); // store copy of current calculate death stats in dom for retreival by legend code
                    // var colorValue = colorScale(stats);

                    //https://stackoverflow.com/questions/20340263/d3-retrieve-and-add-to-current-selections-attribute-value
                    var currentFillOpacity = +d3.select(this).style("fill-opacity");
                    var currentFillColor = d3.select(this).style("fill");

                    // console.log(currentFillOpacity);
                    var setFillOpacity = null;
                    var currentDeathRateValue = +this.getAttribute('value')
                    if (currentDeathRateValue >= lowerBound && currentDeathRateValue < upperBound) {
                        if (currentFillOpacity == selectedFillOpacity) {
                            // selected state -> unselected
                            setFillOpacity = d3.select(this).style("fill-opacity", unSelectedFillOpacity);
                            var unSelectedFillColor = d3.select(this).attr("originalFillColor");
                            d3.select(this).style("fill", unSelectedFillColor);


                        } else { // unselected state -> selected
                            // selection detected, set selected opacity and fill
                            setFillOpacity = d3.select(this).style("fill-opacity", selectedFillOpacity);

                            // not currently selected
                            // save original Fill Color
                            d3.select(this).attr("originalFillColor", currentFillColor);
                            // now set state to selected fill color
                            d3.select(this).style("fill", selectedFillColor);


                        }
                    } else {
                        setFillOpacity = currentFillOpacity;
                    }

                    // console.log(this.getAttribute('value'));
                    return setFillOpacity;
                })
                ;
        }

        /*
            custom function as ticks method in D3 does not allow
            number of ticks to be absolute.
        */
        function getTickArray(scale) {
            domain = scale.domain();
            range = scale.range();
            domainLength = scale.domain()[1] - scale.domain()[0];
            binSize = domainLength / (range.length - 1);
            var tickArray = [];
            for (i = 0; i < range.length; i++) {
                tickArray.push(i * binSize);

            }
            return tickArray;
        }

        function isStrict(fn) {
            if (typeof fn != "function")
                throw new TypeError("expected function");
            try {
                fn.caller; // expected to throw
                return false;
            } catch (e) {
                return true;
            }
        }

        // end slider code

        // add button code
        //backdrop of color
        // var background= svg.append("rect")
        //     .attr("id","backgroundRect")
        //     .attr("width",300)
        //     .attr("height",50)
        //     .attr("x", 0)
        //     .attr("y", genderButtonsGroupY)
        //     .attr("fill","#DAC99A")


        //container for gender buttons
        var genderButtons = svg.append("g")
            .attr("id", "genderButtons")
            .attr("transform", "translate(50, " + genderButtonsGroupY + ")");
        //container for year buttons
        var yearButtons = svg.append("g")
            .attr("id", "yearButtons")
            .attr("transform", "translate(50, " + yearButtonsGroupY + ")");

        var rawButtons = svg.append('g')
            .attr("id", "rawButtons")
            .attr("transform", "translate(50, " + rawButtonsGroupY + ")");

        //text that the radio button will toggle
        var number = genderButtons.append("text")
            .attr("id", "numberToggle")
            .attr("x", 180)
            .attr("y", 30)
            .attr("fill", "green")
            .attr("font-size", 24)
        // .text("[click a button]")
        //groups for each gender button (which will hold a rect and text)
        var buttonGroups = genderButtons.selectAll("g.button.gender")
            .data(labelsGender)
            .enter()
            .append("g")
            //.attr("class", "button")
            .attr("class", function (d, i) { return "button gender " + labelsId[i] })
            .style("cursor", "pointer")
            .on("click", function (d, i) {
                updateButtonColors(d3.select(this), d3.select(this.parentNode));
                // d3.select("#numberToggle").text(i+1)
            })
            .on("mouseover", function () {
                if (d3.select(this).select("rect").attr("fill") != pressedColor) {
                    d3.select(this)
                        .select("rect")
                        .attr("fill", hoverColor);
                }
            })
            .on("mouseout", function () {
                if (d3.select(this).select("rect").attr("fill") != pressedColor) {
                    d3.select(this)
                        .select("rect")
                        .attr("fill", defaultColor);
                }
            })

        //groups for each year button (which will hold a rect and text)
        var yearGroups = yearButtons.selectAll("g.button.year")
            .data(labelsYear)
            .enter()
            .append("g")
            .attr("class", "button")
            .attr("class", function (d, i) { return "button year " + labelsYearId[i] })
            .style("cursor", "pointer")
            .on("click", function (d, i) {
                updateButtonColorsYear(d3.select(this), d3.select(this.parentNode));
                // d3.select("#numberToggle").text(i+1)
            })
            .on("mouseover", function () {
                if (d3.select(this).select("rect").attr("fill") != pressedColor) {
                    d3.select(this)
                        .select("rect")
                        .attr("fill", hoverColor);
                }
            })
            .on("mouseout", function () {
                if (d3.select(this).select("rect").attr("fill") != pressedColor) {
                    d3.select(this)
                        .select("rect")
                        .attr("fill", defaultColor);
                }
            })

        //adding a rect to each toggle button group
        //rx and ry give the rect rounded corner
        buttonGroups.append("rect")
            .attr("class", "buttonRect")
            .attr("width", bWidth)
            .attr("height", bHeight)
            .attr("x", function (d, i) { return x0 + (bWidth + bSpace) * i; })
            .attr("y", y0)
            .attr("rx", 5) //rx and ry give the buttons rounded corners
            .attr("ry", 5)
            .attr("fill", defaultColor)

        //rx and ry give the rect rounded corner
        yearGroups.append("rect")
            .attr("class", "buttonRect")
            .attr("width", bWidth)
            .attr("height", bHeight)
            .attr("x", function (d, i) { return x0 + (bWidth + bSpace) * i; })
            .attr("y", y0)
            .attr("rx", 5) //rx and ry give the buttons rounded corners
            .attr("ry", 5)
            //.attr("fill", defaultColor)
            .attr("fill", function (d, i) {
                if (i == 0) {
                    return pressedColor;
                }
                return defaultColor;
            })
        //adding text to each toggle button group, centered
        //within the toggle button rect
        buttonGroups.append("text")
            .attr("class", "buttonText")
            .attr("font-family", "FontAwesome")
            .attr("x", function (d, i) {
                return x0 + (bWidth + bSpace) * i + bWidth / 2;
            })
            .attr("y", y0 + bHeight / 2)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "central")
            .attr("fill", "white")
            .text(function (d) { return d; })
        //adding text to each toggle button group, centered
        //within the toggle button rect
        yearGroups.append("text")
            .attr("class", "buttonText")
            .attr("font-family", "FontAwesome")
            .attr("x", function (d, i) {
                return x0 + (bWidth + bSpace) * i + bWidth / 2;
            })
            .attr("y", y0 + bHeight / 2)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "central")
            .attr("fill", "white")
            .text(function (d) { return d; })


        var rawGroup = rawButtons.selectAll("g.button.raw")
            .data(labelsRawData)
            .enter()
            .append("g")
            .attr("class", "button")
            .attr("class", function (d, i) { return "button raw " + labelsRawDataID[i] })
            .style("cursor", "pointer")
            .on("click", function (d, i) {
                updateButtonColorsRaw(d3.select(this), d3.select(this.parentNode));
            })
            .on("mouseover", function () {
                if (d3.select(this).select("rect").attr("fill") != pressedColor) {
                    d3.select(this)
                        .select("rect")
                        .attr("fill", hoverColor);
                }
            })
            .on("mouseout", function () {
                if (d3.select(this).select("rect").attr("fill") != pressedColor) {
                    d3.select(this)
                        .select("rect")
                        .attr("fill", defaultColor);
                }
            })

        rawGroup.append("rect")
            .attr("class", "buttonRect")
            .attr("width", bWidth)
            .attr("height", bHeight)
            .attr("x", function (d, i) { return x0 + (bWidth + bSpace) * i; })
            .attr("y", y0)
            .attr("rx", 5) //rx and ry give the buttons rounded corners
            .attr("ry", 5)
            //.attr("fill", defaultColor)
            .attr("fill", function (d, i) {
                if (i == 0) {
                    return defaultColor;
                }
                return defaultColor;
            })

        rawGroup.append("text")
            .attr("class", "buttonText")
            .attr("font-family", "FontAwesome")
            .attr("x", function (d, i) {
                return x0 + (bWidth + bSpace) * i + bWidth / 2;
            })
            .attr("y", y0 + bHeight / 2)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "central")
            .attr("fill", "white")
            .text(function (d) { return d; })

        function updateButtonColors(button, parent) {
            parent.selectAll("rect")
                .attr("fill", defaultColor)

            button.select("rect")
                .attr("fill", pressedColor)
            // one place to update visualization
            genderSelected = button.attr("class").split(" ")[2]; // set global for which gender selected
            updateChoropleth("gender");
        }


        function updateButtonColorsYear(button, parent) {
            parent.selectAll("rect")
                .attr("fill", defaultColor)

            button.select("rect")
                .attr("fill", pressedColor)
            // one place to update visualization
            tempDeathRateyear = button.attr("class").split(" ")[2]; // set global for which year selected
            deathRateYear = +tempDeathRateyear.split("_")[1]; // set global for which year selected
            updateChoropleth("year");
        }

        function updateButtonColorsRaw(button, parent) {
            rawDataFlag = !rawDataFlag;
            parent.selectAll("rect")
                .attr("fill", defaultColor)

            button.select("rect")
                .attr("fill", (rawDataFlag ? pressedColor : defaultColor))
            // one place to update visualization


            threshold = (rawDataFlag ? [50, 100, 250, 500, 1000] : [1, 3, 6, 9, 11]);
            colorScale = d3.scaleThreshold()
                .domain(threshold) // currently needed to manually deterine domain by hand based on data.
                .range(colorRange);
            svg.append("g")
                .attr("class", "legendThreshold")
                .attr("transform", "translate(785,570)");

            var numFormat = (rawDataFlag ? '0' : ".2f");
            var legendThreshold = d3.legendColor()
                .labelFormat(d3.format(numFormat))
                .labels(d3.legendHelpers.thresholdLabels)
                .useClass(false) /// this was originall true, needed to make it false to work.
                .scale(colorScale);

            svg.select(".legendThreshold")
                .call(legendThreshold);

            // attach legend handlers
            d3.selectAll("g.cell")
                //.attr("fill", function(d, i) {if (i == 0) return "blue"; if (i == 1) return "red"; return "green"})
                .attr("selected", "false")
                .on('click', null)
                .on('click', function (d, i) {
                    // handle events here
                    // d - datum
                    // i - identifier or index
                    // this - the `<rect>` that was clicked
                    var selected = this.getAttribute('selected');
                    var textVal = d3.select(this).select("text.label").text();
                    var bounds = getBounds(textVal); // should return a 2 element array index 0 lower, index1 upper
                    var lowerBound = bounds[0];
                    var upperBound = bounds[1];
                    var rectangle = d3.select(this).select("rect.swatch");
                    toggleLegendState(lowerBound, upperBound, this);
                });

            updateChoropleth("All");
        }

        // append legend Threshold
        svg.append("g")
            .attr("class", "legendThreshold")
            .attr("transform", "translate(785,570)");

        var numFormat = (rawDataFlag ? '0' : ".2f");
        var legendThreshold = d3.legendColor()
            .labelFormat(d3.format(numFormat))
            .labels(d3.legendHelpers.thresholdLabels)
            .useClass(false) /// this was originall true, needed to make it false to work.
            .scale(colorScale);

        svg.select(".legendThreshold")
            .call(legendThreshold);

        // attach legend handlers
        d3.selectAll("g.cell")
            //.attr("fill", function(d, i) {if (i == 0) return "blue"; if (i == 1) return "red"; return "green"})
            .attr("selected", "false")
            .on('click', null)
            .on('click', function (d, i) {
                // handle events here
                // d - datum
                // i - identifier or index
                // this - the `<rect>` that was clicked
                var selected = this.getAttribute('selected');
                var textVal = d3.select(this).select("text.label").text();
                var bounds = getBounds(textVal); // should return a 2 element array index 0 lower, index1 upper
                var lowerBound = bounds[0];
                var upperBound = bounds[1];
                var rectangle = d3.select(this).select("rect.swatch");
                toggleLegendState(lowerBound, upperBound, this);
            });

        function unSelectAllStates() {
            d3.selectAll("g.cell")
                //.attr("fill", function(d, i) {if (i == 0) return "blue"; if (i == 1) return "red"; return "green"})
                .attr("selected", function (d, i) {
                    // handle events here
                    // d - datum
                    // i - identifier or index
                    // this - the `<rect>` that was clicked
                    var selected = this.getAttribute('selected');
                    var textVal = d3.select(this).select("text.label").text();
                    var bounds = getBounds(textVal); // should return a 2 element array index 0 lower, index1 upper
                    var lowerBound = bounds[0];
                    var upperBound = bounds[1];
                    // console.log(bounds);
                    if (selected == "true") {

                        toggleLegendState(lowerBound, upperBound, this);
                    }

                    return "false";
                })
                ;
        }

        function getBounds(parseText) {
            var str = parseText.split(" ");
            // https://stackoverflow.com/questions/1352577/check-that-variable-is-a-number
            var lower = +str[0];
            var val1 = +str[1];
            var upper = +str[2];
            var upperLimit = rawDataFlag ? 2000 : 100;
            if (isFinite(+lower) == true && isFinite(+upper) == true) {
                return [lower, upper];
            } else if (str[0] === "Less") {
                return [0, upper];
            } else {
                return [upper, upperLimit];
            }
        }
        // end append legend

        function getStatePrevalence(state, impairedData) {
            for (var i = 0; i < impairedData.length; i++) {
                if (state == impairedData[i].State) {
                    return impairedData[i]["Prevalence"];
                }
            }
        }

        function getStateDeathRate(state, impairedData) {
            for (var i = 0; i < impairedData.length; i++) {
                if (state == impairedData[i].State) {
                    return impairedData[i]["Impaired Driving Death Rate"];
                }
            }
        }

        function getStatePopulation(name, aggData) {
            console.log("here");
        }

        function getStateDeathRateV2(state, filterPath) {
            if (state === "Washington DC") {
                state = "District of Columbia"; // fixes issue of state mismatch on DC
            }

            var result = aggDataPersisted.filter(function (obj) { return obj['State '] == state; });
            var stats = 0;
            var columnTitle = "";
            var populationTitle = "Population, " + deathRateYear;
            var population = result[0][populationTitle];
            //console.log(filterPath);
            // if filter path comes from gender.
            if (filterPath === "gender") {
                // two cases
                // case 1: if gender is both, let ageRangeSelected pass on through tocolumn title
                if (genderSelected === "Both") {
                    columnTitle = ageRangeSelected + ", " + deathRateYear;
                } else {
                    // gender is either male or female, hence show either all Male/Female for particularyear
                    columnTitle = genderSelected + ", " + deathRateYear;
                    // reset ageRange to All Ages
                    //*** TODO
                    ageRange(0); // resetting ageRange handle to All Ages
                }

            } else if (filterPath === "ageRange") {
                // path comes from ageRange
                columnTitle = "ageRangeSelected" + ", " + deathRateYear;
                // reset gender to both
                updateButtonColors(d3.select("g.button.both"), d3.select("#genderButtons"));
            } else {
                // filter path must be "year"
                if (genderSelected === "Both") {
                    columnTitle = ageRangeSelected + ", " + deathRateYear;
                } else {
                    // A gender must be selected
                    columnTitle = genderSelected + ", " + deathRateYear;
                }

            }

            if (result[0][columnTitle] === undefined) {
                stats = 0;
            } else {
                stats = +result[0][columnTitle];
            }

            if (rawDataFlag) {
                stats = Math.round(population / 100000 * stats);
            }

            return stats;
        }


        // Utility methods
        // ref: https://stackoverflow.com/questions/7893776/the-most-accurate-way-to-check-js-objects-type
        // s as:
        /*
            type(function(){}); // -> "function"
            type([1, 2, 3]); // -> "array"
            type(new Date()); // -> "date"
            type({}); // -> "object"

        */
        var type = (function (global) {
            var cache = {};
            return function (obj) {
                var key;
                return obj === null ? 'null' // null
                    : obj === global ? 'global' // window in browser or global in nodejs
                        : (key = typeof obj) !== 'object' ? key // basic: string, boolean, number, undefined, function
                            : obj.nodeType ? 'object' // DOM element
                                : cache[key = ({}).toString.call(obj)] // cached. date, regexp, error, object, array, math
                                || (cache[key] = key.slice(8, -1).toLowerCase()); // get XXXX from [object XXXX], and cache it
            };
        }(this));

        // Utility Functions
        // Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
        // Closure
        (function() {
          /**
           * Decimal adjustment of a number.
           *
           * @param {String}  type  The type of adjustment.
           * @param {Number}  value The number.
           * @param {Integer} exp   The exponent (the 10 logarithm of the adjustment base).
           * @returns {Number} The adjusted value.
           */
          function decimalAdjust(type, value, exp) {
            // If the exp is undefined or zero...
            if (typeof exp === 'undefined' || +exp === 0) {
              return Math[type](value);
            }
            value = +value;
            exp = +exp;
            // If the value is not a number or the exp is not an integer...
            if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
              return NaN;
            }
            // If the value is negative...
            if (value < 0) {
              return -decimalAdjust(type, -value, exp);
            }
            // Shift
            value = value.toString().split('e');
            value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
            // Shift back
            value = value.toString().split('e');
            return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
          }

          // Decimal round
          if (!Math.round10) {
            Math.round10 = function(value, exp) {
              return decimalAdjust('round', value, exp);
            };
          }
          // Decimal floor
          if (!Math.floor10) {
            Math.floor10 = function(value, exp) {
              return decimalAdjust('floor', value, exp);
            };
          }
          // Decimal ceil
          if (!Math.ceil10) {
            Math.ceil10 = function(value, exp) {
              return decimalAdjust('ceil', value, exp);
            };
          }
        })();

        function regressData(aggDataPersisted) {
            var yearChoices = [2012, 2014];
            var categoryChoices = ["Ages 0-20", "Ages 21-34", "Ages 35+", "All Ages", "Female", "Male", "Population"];
            var index;
            for(index = 0, len = aggDataPersisted.length; index < len; ++index ){ //52 states
                for(index1 = 0, len1 = categoryChoices.length; index1 < len1; ++index1){
                    var known_x = [];
                    var known_y = []
                    for(index2 = 0, len2 = yearChoices.length; index2 < len2; ++index2){
                        known_x.push(index2);
                        var year = yearChoices[index2];
                        var value = +aggDataPersisted[index][categoryChoices[index1] + ", " + yearChoices[index2]];
                        known_y.push(value);

                    }
                    var lr  = linearRegression(known_y, known_x);
                    // could eventually create  loop to predict and set more than 1 year
                    var newY = lr.fn(2);
                    aggDataPersisted[index][categoryChoices[index1] + ", " + 2016] = newY.toString();

                }            
            }

        }
    </script>

</body>
<script>
    // ensure both male and female are selected by default (add after body tag so Dom is completely loaded.)
        //updateButtonColors(d3.select("g.button.both"), d3.select("#genderButtons"));

</script>


</html>
