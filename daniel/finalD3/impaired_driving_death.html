<htmL>

<head>
    <meta charset="UTF-8">
    <title>Impaired Driving Death Rate by Age, Gender, and State</title>
    <script type="text/javascript" src="libraries/d3.js"></script>
    <!-- <script src="//d3js.org/d3.v4.min.js"></script> -->
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <script type="text/javascript" src="libraries/d3-legend-2.24.0/d3-legend.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">


    <!-- removes any default padding and style -->
    <style>
        body {
            padding: 0;
            margin: 0;
        }

        h1 {
            font-family: arial;
            font-size: 1em;
            color: #333;
        }

        .title {
            text-align: center;
            font-family: arial;
            font-size: 2em;
            color: #333;
        }

        .background {
            fill: none;
            pointer-events: all;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
        }

        .states {
            fill: #e5e5e5;
            stroke: #fff;
            stroke-width: 2px;
            cursor: pointer;
        }

        .states.active {
            fill: lightseagreen;
        }

        .states:hover {
            fill: steelblue;
        }
        /* slider styling */

        .track {
            stroke: #000;
            stroke-opacity: 0.3;
            stroke-width: 10px;
        }

        .track-inset {
            stroke: #ddd;
            stroke-width: 8px;
        }

        .track-overlay {
            pointer-events: stroke;
            stroke-width: 50px;
            cursor: crosshair;
        }

        .handle {
            fill: #fff;
            stroke: #000;
            stroke-opacity: 0.5;
            stroke-width: 1.25px;
        }
        /* Bar Chart */

        .bar {
        }

        .bar:hover {
            fill: lightskyblue;
        }

        .bar.active {
            fill: lightseagreen
        }

        .axis {
            font: 10px arial;
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }
    </style>
</head>

<body>
    <div class="title">
        Impaired Driving Death Rate for 2012 and 2014
    </div>


    <div id="info">
        <h1 id="name"></h1>
    </div>
    <script>
        /* Final d3 Assignment
		* Peter Thung, Daniel Vance
        * Sources:
        *   Map Data -> http://bl.ocks.org/mapsam/6083585
        *   Impaired driving data -> https://www.cdc.gov/motorvehiclesafety/impaired_driving/states-data-tables.html
        *   Added fill color to choropleth map, based on % driving death rate.
        *   Zoom transition -> https://bl.ocks.org/mbostock/4699541
        *   Added threshold legend utilzing http://d3-legend.susielu.com/#color-threshold
        *           Note: there was an issue with .useClass(true) method, making
        *                 the squares in the legend all black.
        *   Slider for year -> http://bl.ocks.org/darrenjaworski/5397202
        *   Added code to link choropleth graph to change based on year selected.
        *   visualized death rates for age groups as well as gender.
        *   Histogram -> http://bl.ocks.org/jensgrubert/7777399
        *   added legend key state selection fill/unfill
        *   Added initial transition of States to assemble like jig saw puzzle from random points away from center upon refersh of page.
        *   Added button for year selection, initialzing 2012 button selected upon initial page load. (Note need to remove yearSlider)
        *   Removed the year Slider bar and slipped in the year buttons in it's place.
		*/
        var w = 960,
            h = 700,
            active = d3.select(null),
            deathRateFlag = true;
        var deathRateYear = 2012;

        var ageRangeSelected = "All Ages"; // e.g. All Ages, Ages 0-20, Ages 21-34, Ages 35+
        var aggDataPersisted;
        var usPersisted;
        var prevalenceDataPersisted;
        var deathRateDataPersisted;

        var yearSliderY = 585;
        var genderButtonsGroupY = 610;
        var yearButtonsGroupY = 560;
        var ageRangeSliderY = 665;

        var threshold = [1, 3, 6, 9, 11];
        var colorRange = ["#f2f0f7", "#dadaeb", "#bcbddc",
            "#9e9ac8", "#756bb1", "#54278f"];

        var lastFilterPath = null;

        // globals in support of legend selection
        var selectedFillOpacity = .85;
        var unSelectedFillOpacity = 1;
        var selectedFillColor = d3.color("Orange");

        // Globals in support of Buttons
        //fontawesome button labels
        var labelsGender = ['\uf183', '\uf182', '\uf0c0'];
        var labelsId = ['Male', 'Female', 'Both'];
        var labelsYear = ['2012', '2014'];
        var labelsYearId = ['a_2012', 'a_2014'];

        var genderSelected = labelsId[2];  // default both
        //colors for different button states
        var defaultColor = "#7777BB"
        var hoverColor = "#0000ff"
        var pressedColor = "#000077"
        var pressedColor2 = "#080077"
        var bWidth = 40; //button width
        var bHeight = 25; //button height
        var bSpace = 10; //space between buttons
        var x0 = 20; //x offset
        var y0 = 10; //y offset
        // end globals in support of buttons

        // BarChart
        var x = d3.scaleBand().domain(["Female 2012", "Male 2012", "Female 2014", "Male 2014"])
            .range([0, 650])
            .paddingOuter(0.1);
        var y = d3.scaleLinear();

        var xAxis = d3.axisBottom(x)
            .ticks(4);
        var yAxis = d3.axisLeft(y)
            .ticks(6);
        // End Bar Chart

        var svg = d3.select("body").append("svg")
            .attr("width", w)
            .attr("height", h)
        //  .attr("style", "border: 2px solid #aaaaaa;")

        // var title = svg.selectAll(".title").append("div")

        var margin = { right: 50, left: 50 },
            width = +svg.attr("width") - margin.left - margin.right,
            height = +svg.attr("height");

        var colorScale = d3.scaleThreshold()
            .domain(threshold) // currently needed to manually deterine domain by hand based on data.
            .range(colorRange);

        var g = svg.append("g")
            .style("stroke-width", "1.5px");

        var projection = d3.geoAlbersUsa()
            .scale(1000)
            .translate([w / 2, h / 2]);

        var path = d3.geoPath(projection);

        var geoProjection = d3.geoConicEqualArea()
            .scale(1000)
            .translate([w / 2, h / 2]);

        function getStatePrevalence(state, impairedData) {
            for (var i = 0; i < impairedData.length; i++) {
                if (state == impairedData[i].State) {
                    return impairedData[i]["Prevalence"];
                }
            }
        }

        function getStateDeathRate(state, impairedData) {
            for (var i = 0; i < impairedData.length; i++) {
                if (state == impairedData[i].State) {
                    return impairedData[i]["Impaired Driving Death Rate"];
                }
            }
        }

        d3.csv("data/impaired-driving-prevalence-2012-all-states.csv", function (error, prevalenceData) {
            if (error) return console.warn(error);
            prevalenceDataPersisted = prevalenceData;
            d3.csv("data/impaireddrivingdeathrate.csv", function (error, deathRateData) {
                if (error) return console.warn(error);
                deathRateDataPersisted = deathRateData;
                d3.csv("data/Impaired_Driving_Death_Rate.csv", function (error, aggData) {
                    aggDataPersisted = aggData;
                    if (error) return console.warn(error);
                    d3.json("data/us.json", function (error, us) {
                        if (error) throw error;
                        usPersisted = us;

                        g.selectAll('.states')
                            .data(topojson.feature(us, us.objects.usStates).features)
                            .enter()
                            .append('path')

                            .attr("class", "states")

                            // .transition()
                            //    .attr("transform", function (d, i) {
                            //         return "translate(" + Math.random() * (-50) + "," + Math.random() * (-50) + ")" })
                            //    .duration(3000)

                            .attr('d', path)
                            .on('mouseover', function (d) {
                                svg.selectAll("incidents").remove();
                                var name = d.properties.STATE_ABBR;
                                var prevalence = getStatePrevalence(name, prevalenceData),
                                    deathRate = getStateDeathRate(name, deathRateData);
                                if (!prevalence) prevalence = 0;
                                if (!deathRate) deathRate = 0;

                                return document.getElementById('name').innerHTML = name + ": </br>Prevalence: " + prevalence
                                    + "%</br>Death Rate: " + deathRate + "%";
                            })
                            .on("click", clicked)

                           .style("fill", "none")
                           .attr("transform", function (d, i) {
                                // https://stackoverflow.com/questions/8611830/javascript-random-positive-or-negative-number
                                var plusOrMinus1 = Math.random() < 0.5 ? -1 : 1;
                                var plusOrMinus2 = Math.random() < 0.5 ? -1 : 1;
                                var lh = 400;//h;
                                var lw = 400;//w;
                                return "translate(" + (plusOrMinus1 * d3.randomUniform(lh, lh + 200)()) + "," + (plusOrMinus2 * d3.randomUniform(lw, lw + 200)())  + ") rotate(" + d3.randomUniform(0, 360)() + ")" })

                            .transition()
                                .style("fill", function (d) {
                                    var name = d.properties.STATE_ABBR;
                                    var stats;
                                    if (deathRateFlag) {
                                        stats = getStateDeathRate(name, deathRateData);
                                    } else {
                                        stats = getStatePrevalence(name, prevalenceData);
                                    }
                                    var colorValue = colorScale(stats);
                                    return colorScale(stats); // <-D
                                })
                                .attr("transform", function (d, i) {
                                    return "translate(" +  (0) + "," +  (0) + ")" })
                               .duration(3000)
                            // .transition()
                            //     .delay(3000)
                            
                            ;
                        updateButtonColors(d3.select("g.button.both"), d3.select("#genderButtons"));
                    });
                });
            });
        });

        var chart = svg.append("g")
            .attr("class", "chart")
            .attr("transform", "translate(150, 550)");

        function clicked(d) {
            if (active.node() === this) {
                return reset()
            }
            active.classed("active", false);
            active = d3.select(this).classed("active", true);

            var bounds = path.bounds(d),
                dx = bounds[1][0] - bounds[0][0],
                dy = bounds[1][1] - bounds[0][1],
                x = (bounds[0][0] + bounds[1][0]) / 2,
                y = (bounds[0][1] + bounds[1][1]) / 2,
                scale = .8 / Math.max(dx / w, dy / h),
                translate = [w / 2 - scale * x, h / 2 - scale * y];

            g.transition()
                .duration(750)
                .style("stroke-width", 1.5 / scale + "px")
                .attr("transform", "translate(" + translate + ")scale(" + scale + ")");
            g.append("rect")
                .attr("x", "0")
                .attr("y", "0")
                .attr("width", w / 20)
                .attr("height", h / 15)
                .attr("transform", "translate(" + translate + ")scale(" + scale + ")");

            newBarChart(d);
        }

        function newBarChart(data) {
            chart.selectAll("g").remove()
            chart.selectAll("rect").remove();

            var tmpGender = genderSelected;
            var tmpAge = ageRangeSelected;
            var tmpYear = deathRateYear;
            var gender = ["Female", "Male"];
            var year = ["2012", "2014"];
            var results = [];
            var name;

            gender.forEach(function (g) {
                year.forEach(function (y) {
                    name = "" + g + " " + y;
                    genderSelected = g;
                    deathRateYear = y;
                    results.push({
                        "name": name,
                        "gender": g,
                        "year": y,
                        "stats": getStateDeathRateV2(data.properties.STATE_ABBR, "gender")
                    });
                });
            });

            deathRateYear = tmpYear;
            genderSelected = tmpGender;
            ageRangeSelected = tmpAge;

            var max = [];
            results.forEach(function (r) {
                max.push(r.stats);
            });

            yMax = d3.max(max);
            y.domain([0, yMax])
                .range([400, 0]);

            chart.append("g")
                .attr("class", "x axis")
                .call(xAxis)
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "2.5em");

            chart.append("g")
                .attr("class", "y axis")
                .attr("transform", "translate(0, -400)")
                .call(yAxis)
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Value ($)");

            var bar = chart.selectAll(".bar")
                .remove()
                .exit()
                .data(results)

            bar.enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", function (d) {
                    return x(d.name);
                })
                .attr("width", 100)
                .attr("y", function (d) { return y(d.stats); })
                .attr("height", function (d) {  return (400 - y(d.stats)); })
                .attr("transform", "translate(20, -400)")
                .attr("fill", function(d) {
                    if(d.gender == "Female"){
                        return "rgb(230, 180, 180)";
                    } else {
                        return "rgb(180, 230, 230)";
                    }
                });
        }

        function reset() {
            chart.selectAll("g").remove();
            chart.selectAll("rect").remove();
            active.classed("active", false);
            active = d3.select(null);
            g.transition()
                .duration(750)
                .style("stroke-width", "1.5px")
                .attr("transform", "");

        }

        // add D3 Radio Buttons to represent Male/Female/Both selections to access those particular
        // data




        // add   Age Range
        // var x = d3.scaleLinear()
        //var yearList = [2012, 2013, 2014, 2015, 2016];  // test for greater number of years

        var ageRangeList = ["All Ages", "Ages 0-20", "Ages 21-34", "Ages 35+"];
        var sliderBarPixelDomain = [0, 600];


        var xAgeRange = d3.scaleQuantile()
            .domain(sliderBarPixelDomain)
            .range(ageRangeList);
        //.clamp(true); // does not exist for d3.scaleQuantize



        var sliderAgeRange = svg.append("g")
            .attr("class", "slider ageRange")
            .attr("transform", "translate(" + margin.left + "," + ageRangeSliderY + ")");



        sliderAgeRange.append("line")
            .attr("class", "track")
            .attr("x1", xAgeRange.domain()[0])
            .attr("x2", xAgeRange.domain()[1])
            .select(function () { return this.parentNode.appendChild(this.cloneNode(true)); })
            .attr("class", "track-inset")
            .select(function () { return this.parentNode.appendChild(this.cloneNode(true)); })
            .attr("class", "track-overlay")
            .call(d3.drag()
                .on("start.interrupt", function () { sliderAgeRange.interrupt(); })
                .on("start drag", function () {
                    ageRange(d3.event.x); // so deathRateYear is updated while it is being dragged vice on dragended.  May have effect of updating choropleth as slider is being slid, if we had more than two years.
                    updateChoropleth("ageRange");
                })
                .on("end", dragendedAgeRange)
            )
            ;



        sliderAgeRange.insert("g", ".track-overlay")
            .attr("class", "ticks")
            .attr("transform", "translate(0," + 30 + ")") // controls how many pixels below bar
            .selectAll("text")
            .data(getTickArray(xAgeRange))
            .enter().append("text")
            .attr("x", function (d) { return d; })
            .attr("text-anchor", "middle")
            .text(function (d) {
                //console.log(xYear(d));
                return xAgeRange(d);
            });



        var handleAgeRange = sliderAgeRange.insert("circle", ".track-overlay")
            .attr("class", "handle ageRange")
            .attr("r", 9);



        function ageRange(xActual) {
            // code below fixes the actual handle to snap to the tick marks
            // for ranges that
            var xExtent = xAgeRange.invertExtent(xAgeRange(xActual));
            var xExtentLeft = xExtent[0];
            var xExtentRight = xExtent[1];
            var xExtentMid = (xExtentLeft + xExtentRight) / 2;
            var xPixelLocation;
            if (xExtentRight === xAgeRange.domain()[1]) {
                handleAgeRange.attr("cx", xAgeRange.domain()[1]);
            } else if (xExtentLeft === xAgeRange.domain()[0]) {
                handleAgeRange.attr("cx", xAgeRange.domain()[0]);
            } else {
                handleAgeRange.attr("cx", xExtentMid);
            }
            ageRangeSelected = xAgeRange(xActual);
        }



        function dragendedAgeRange(d) {
            updateChoropleth("ageRange");
        }

        function updateChoropleth(filterPath) {
            unSelectAllStates(); // to prevent unintended selection of states based on new data
                                 // need to do this first, prior to changing states else 
                                 // if states are selected, would be overiding previous state fill color
            // re-calculate death rate colors.
            var states = svg.selectAll('.states')
                .data(topojson.feature(usPersisted, usPersisted.objects.usStates).features);

            //not expecting less states so not expecting this to do anything
            states.exit().remove();

            // planning on skipping .enter() as not expecting any new states
            // // udpate
            states.merge(states)
                .style("fill", function (d) {
                    //console.log(d);
                    var name = d.properties.STATE_ABBR;
                    var result = aggDataPersisted.filter(function (obj) { return obj['State '] == name; });
                    var stats = getStateDeathRateV2(name, filterPath);
                    tempDeathRate = stats;
                    // ref: https://stackoverflow.com/questions/3363463/append-custom-attributes-to-a-dom-node
                    this.setAttribute('value', stats); // store copy of current calculate death stats in dom for retreival by legend code
                    var colorValue = colorScale(stats);
                    return colorScale(stats);
                })
                .on('mouseover', function (d) {
                    svg.selectAll("incidents").remove();
                    var name = d.properties.STATE_ABBR;
                    if (name === "Washington DC") {
                        name = "District of Columbia"; // fixes issue where
                    }
                    var prevalence = getStatePrevalence(name, prevalenceDataPersisted);
                    var deathRate = getStateDeathRateV2(name, filterPath);
                    if (!prevalence) prevalence = 0;
                    if (!deathRate) deathRate = 0;

                    return document.getElementById('name').innerHTML = name + ": </br>Prevalence: " + prevalence
                        + "%</br>Death Rate: " + deathRate + "%";
                })
                .on("click", clicked);
                

        }

        // outlineStateBasedOnDeathRateValue
        function toggleLegendState(lowerBound, upperBound, cell) {

                            // console.log(bounds);


            // check for cell state
            var cellState = cell.getAttribute('selected');
            if(cellState === "true") {
                // cell is selected -> unselected
                // update legend rectange fill color to original  and cell state to false
                
                cell.setAttribute('selected', "false");
                var rectangle = d3.select(cell).select("rect.swatch")
                var unSelectedRectangleFillColor = rectangle.attr("originalFillColor");
                rectangle.style("fill", unSelectedRectangleFillColor);
                rectangle.style("fill-opacity", unSelectedFillOpacity);
            } else {
                // cell is unselected -> selected
                // save off original rectangle fill color
                var rectangle = d3.select(cell).select("rect.swatch")
                var currentRectangleFillColor = rectangle.style("fill");
                rectangle.attr("originalFillColor", currentRectangleFillColor);   
                // update legend rectange fill color to original  and state to false
                cell.setAttribute('selected', "true");
                rectangle.style("fill", selectedFillColor);
                rectangle.style("fill-opacity", selectedFillOpacity);
            }

            // re-calculate death rate colors.
            var states = svg.selectAll('.states')
                .data(topojson.feature(usPersisted, usPersisted.objects.usStates).features);

            //not expecting less states so not expecting this to do anything
            // states.exit().remove();

            // planning on skipping .enter() as not expecting any new states
            // // udpate
            states.merge(states)
                .style("fill-opacity", function (d) {
                    //console.log(d);
                    // var name = d.properties.STATE_ABBR;
                    // var result = aggDataPersisted.filter(function (obj) { return obj['State '] == name; });
                    // var stats = getStateDeathRateV2(name, filterPath);
                    // tempDeathRate = stats;
                    // // ref: https://stackoverflow.com/questions/3363463/append-custom-attributes-to-a-dom-node
                    // this.setAttribute('value', stats); // store copy of current calculate death stats in dom for retreival by legend code
                    // var colorValue = colorScale(stats);

                    //https://stackoverflow.com/questions/20340263/d3-retrieve-and-add-to-current-selections-attribute-value
                    var currentFillOpacity = +d3.select(this).style("fill-opacity");
                    var currentFillColor = d3.select(this).style("fill");

                    // console.log(currentFillOpacity);
                    var setFillOpacity = null;
                    var currentDeathRateValue = +this.getAttribute('value')
                    if(currentDeathRateValue >= lowerBound && currentDeathRateValue < upperBound) {
                        if(currentFillOpacity == selectedFillOpacity) {
                            // selected state -> unselected
                            setFillOpacity = d3.select(this).style("fill-opacity", unSelectedFillOpacity);
                            var unSelectedFillColor = d3.select(this).attr("originalFillColor");
                            d3.select(this).style("fill", unSelectedFillColor);


                        } else { // unselected state -> selected
                            // selection detected, set selected opacity and fill
                            setFillOpacity = d3.select(this).style("fill-opacity", selectedFillOpacity);
                            
                            // not currently selected
                            // save original Fill Color
                            d3.select(this).attr("originalFillColor", currentFillColor);
                            // now set state to selected fill color
                            d3.select(this).style("fill", selectedFillColor);

                           
                        }
                    } else {
                        setFillOpacity = currentFillOpacity;
                    }
                    
                    // console.log(this.getAttribute('value'));
                    return setFillOpacity;
                })
                ;
        }

        /*
            custom function as ticks method in D3 does not allow
            number of ticks to be absolute.
        */
        function getTickArray(scale) {
            domain = scale.domain();
            range = scale.range();
            domainLength = scale.domain()[1] - scale.domain()[0];
            binSize = domainLength / (range.length - 1);
            var tickArray = [];
            for (i = 0; i < range.length; i++) {
                tickArray.push(i * binSize);

            }
            return tickArray;
        }

        function isStrict(fn) {
            if (typeof fn != "function")
                throw new TypeError("expected function");
            try {
                fn.caller; // expected to throw
                return false;
            } catch (e) {
                return true;
            }
        }

        // end slider code

        // add button code
        //backdrop of color
        // var background= svg.append("rect")
        //     .attr("id","backgroundRect")
        //     .attr("width",300)
        //     .attr("height",50)
        //     .attr("x", 0)
        //     .attr("y", genderButtonsGroupY)
        //     .attr("fill","#DAC99A")


        //container for gender buttons
        var genderButtons = svg.append("g")
            .attr("id", "genderButtons")
            .attr("transform", "translate(50, " + genderButtonsGroupY + ")");
        //container for year buttons
        var yearButtons = svg.append("g")
            .attr("id", "yearButtons")
            .attr("transform", "translate(50, " + yearButtonsGroupY + ")");            

        //text that the radio button will toggle
        var number = genderButtons.append("text")
            .attr("id", "numberToggle")
            .attr("x", 180)
            .attr("y", 30)
            .attr("fill", "green")
            .attr("font-size", 24)
        // .text("[click a button]")
        //groups for each gender button (which will hold a rect and text)
        var buttonGroups = genderButtons.selectAll("g.button.gender")
            .data(labelsGender)
            .enter()
            .append("g")
            //.attr("class", "button")
            .attr("class", function (d, i) { return "button gender " + labelsId[i] })
            .style("cursor", "pointer")
            .on("click", function (d, i) {
                updateButtonColors(d3.select(this), d3.select(this.parentNode));
                // d3.select("#numberToggle").text(i+1)
            })
            .on("mouseover", function () {
                if (d3.select(this).select("rect").attr("fill") != pressedColor) {
                    d3.select(this)
                        .select("rect")
                        .attr("fill", hoverColor);
                }
            })
            .on("mouseout", function () {
                if (d3.select(this).select("rect").attr("fill") != pressedColor) {
                    d3.select(this)
                        .select("rect")
                        .attr("fill", defaultColor);
                }
            })

        //groups for each year button (which will hold a rect and text)
        var yearGroups = yearButtons.selectAll("g.button.year")
            .data(labelsYear)
            .enter()
            .append("g")
            .attr("class", "button")
            .attr("class", function (d, i) { return "button year " + labelsYearId[i] })
            .style("cursor", "pointer")
            .on("click", function (d, i) {
                updateButtonColorsYear(d3.select(this), d3.select(this.parentNode));
                // d3.select("#numberToggle").text(i+1)
            })
            .on("mouseover", function () {
                if (d3.select(this).select("rect").attr("fill") != pressedColor) {
                    d3.select(this)
                        .select("rect")
                        .attr("fill", hoverColor);
                }
            })
            .on("mouseout", function () {
                if (d3.select(this).select("rect").attr("fill") != pressedColor) {
                    d3.select(this)
                        .select("rect")
                        .attr("fill", defaultColor);
                }
            })

        //adding a rect to each toggle button group
        //rx and ry give the rect rounded corner
        buttonGroups.append("rect")
            .attr("class", "buttonRect")
            .attr("width", bWidth)
            .attr("height", bHeight)
            .attr("x", function (d, i) { return x0 + (bWidth + bSpace) * i; })
            .attr("y", y0)
            .attr("rx", 5) //rx and ry give the buttons rounded corners
            .attr("ry", 5)
            .attr("fill", defaultColor)

        //rx and ry give the rect rounded corner
        yearGroups.append("rect")
            .attr("class", "buttonRect")
            .attr("width", bWidth)
            .attr("height", bHeight)
            .attr("x", function (d, i) { return x0 + (bWidth + bSpace) * i; })
            .attr("y", y0)
            .attr("rx", 5) //rx and ry give the buttons rounded corners
            .attr("ry", 5)
            //.attr("fill", defaultColor)
            .attr("fill", function(d, i) { 
                if(i == 0) {
                    return pressedColor; 
                }
                return defaultColor;
            })            
        //adding text to each toggle button group, centered
        //within the toggle button rect
        buttonGroups.append("text")
            .attr("class", "buttonText")
            .attr("font-family", "FontAwesome")
            .attr("x", function (d, i) {
                return x0 + (bWidth + bSpace) * i + bWidth / 2;
            })
            .attr("y", y0 + bHeight / 2)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "central")
            .attr("fill", "white")
            .text(function (d) { return d; })
        //adding text to each toggle button group, centered
        //within the toggle button rect
        yearGroups.append("text")
            .attr("class", "buttonText")
            .attr("font-family", "FontAwesome")
            .attr("x", function (d, i) {
                return x0 + (bWidth + bSpace) * i + bWidth / 2;
            })
            .attr("y", y0 + bHeight / 2)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "central")
            .attr("fill", "white")
            .text(function (d) { return d; })

        function updateButtonColors(button, parent) {
            parent.selectAll("rect")
                .attr("fill", defaultColor)

            button.select("rect")
                .attr("fill", pressedColor)
            // one place to update visualization
            genderSelected = button.attr("class").split(" ")[2]; // set global for which gender selected
            updateChoropleth("gender");
        }


        function updateButtonColorsYear(button, parent) {
            parent.selectAll("rect")
                .attr("fill", defaultColor)

            button.select("rect")
                .attr("fill", pressedColor)
            // one place to update visualization
            tempDeathRateyear = button.attr("class").split(" ")[2]; // set global for which year selected
            deathRateYear = +tempDeathRateyear.split("_")[1]; // set global for which year selected
            updateChoropleth("year");
        }

        // append legend Threshold
        svg.append("g")
            .attr("class", "legendThreshold")
            .attr("transform", "translate(785,570)");

        var legendThreshold = d3.legendColor()
            .labelFormat(d3.format(".2f"))
            .labels(d3.legendHelpers.thresholdLabels)
            .useClass(false) /// this was originall true, needed to make it false to work.
            .scale(colorScale);

        svg.select(".legendThreshold")
            .call(legendThreshold);

        // attach legend handlers
        d3.selectAll("g.cell")
            //.attr("fill", function(d, i) {if (i == 0) return "blue"; if (i == 1) return "red"; return "green"})
            .attr("selected", "false")
            .on('click', null)
            .on('click', function(d,i) {
                // handle events here
                // d - datum
                // i - identifier or index
                // this - the `<rect>` that was clicked
                var selected = this.getAttribute('selected');
                var textVal = d3.select(this).select("text.label").text();
                var bounds = getBounds(textVal); // should return a 2 element array index 0 lower, index1 upper
                var lowerBound = bounds[0];
                var upperBound = bounds[1];
                var rectangle = d3.select(this).select("rect.swatch");
                toggleLegendState(lowerBound, upperBound, this);
            })
            ;

        function unSelectAllStates() {
            d3.selectAll("g.cell")
            //.attr("fill", function(d, i) {if (i == 0) return "blue"; if (i == 1) return "red"; return "green"})
            .attr("selected", function(d,i) {
                // handle events here
                // d - datum
                // i - identifier or index
                // this - the `<rect>` that was clicked
                var selected = this.getAttribute('selected');
                var textVal = d3.select(this).select("text.label").text();
                var bounds = getBounds(textVal); // should return a 2 element array index 0 lower, index1 upper
                var lowerBound = bounds[0];
                var upperBound = bounds[1];
                // console.log(bounds);
                if(selected == "true") {

                    toggleLegendState(lowerBound, upperBound, this);
                } 
                
                return "false";
            })
            ;
        }

        function getBounds(parseText) {
            var str = parseText.split(" ");
            // https://stackoverflow.com/questions/1352577/check-that-variable-is-a-number
            var lower = +str[0];
            var val1 = +str[1];
            var upper = +str[2];
            if(isFinite(+lower) == true && isFinite(+upper) == true) {
                return [lower, upper];
            } else if (str[0] === "Less") {
                return [0, upper];
            } else {
                return [upper, 100];
            }
        }
        // end append legend

        function getStatePrevalence(state, impairedData) {
            for (var i = 0; i < impairedData.length; i++) {
                if (state == impairedData[i].State) {
                    return impairedData[i]["Prevalence"];
                }
            }
        }

        function getStateDeathRate(state, impairedData) {
            for (var i = 0; i < impairedData.length; i++) {
                if (state == impairedData[i].State) {
                    return impairedData[i]["Impaired Driving Death Rate"];
                }
            }
        }

        function getStateDeathRateV2(state, filterPath) {
            if (state === "Washington DC") {
                state = "District of Columbia"; // fixes issue of state mismatch on DC
            }

            var result = aggDataPersisted.filter(function (obj) { return obj['State '] == state; });
            var stats = 0;
            var columnTitle = "";
            if (deathRateFlag) {
                //console.log(filterPath);
                // if filter path comes from gender.
                if (filterPath === "gender") {
                    // two cases
                    // case 1: if gender is both, let ageRangeSelected pass on through tocolumn title
                    if (genderSelected === "Both") {
                        columnTitle = ageRangeSelected + ", " + deathRateYear;
                    } else {
                        // gender is either male or female, hence show either all Male/Female for particularyear
                        columnTitle = genderSelected + ", " + deathRateYear;
                        // reset ageRange to All Ages
                        //*** TODO
                        ageRange(0); // resetting ageRange handle to All Ages
                    }

                } else if (filterPath === "ageRange") {
                    // path comes from ageRange
                    columnTitle = "ageRangeSelected" + ", " + deathRateYear;
                    // reset gender to both
                    updateButtonColors(d3.select("g.button.both"), d3.select("#genderButtons"));
                } else {
                    // filter path must be "year"
                    if (genderSelected === "Both") {
                        columnTitle = ageRangeSelected + ", " + deathRateYear;
                    } else {
                        // A gender must be selected
                        columnTitle = genderSelected + ", " + deathRateYear;
                    }

                }

                if (result[0][columnTitle] === undefined) {
                    stats = 0;
                } else {
                    stats = +result[0][columnTitle];
                }

            } else {
                stats = getStatePrevalence(name, prevalenceDataPersisted);
            }

            return stats;
        }


        // Utility methods
        // ref: https://stackoverflow.com/questions/7893776/the-most-accurate-way-to-check-js-objects-type
        // s as:
        /*
            type(function(){}); // -> "function"
            type([1, 2, 3]); // -> "array"
            type(new Date()); // -> "date"
            type({}); // -> "object"

        */
        var type = (function (global) {
            var cache = {};
            return function (obj) {
                var key;
                return obj === null ? 'null' // null
                    : obj === global ? 'global' // window in browser or global in nodejs
                        : (key = typeof obj) !== 'object' ? key // basic: string, boolean, number, undefined, function
                            : obj.nodeType ? 'object' // DOM element
                                : cache[key = ({}).toString.call(obj)] // cached. date, regexp, error, object, array, math
                                || (cache[key] = key.slice(8, -1).toLowerCase()); // get XXXX from [object XXXX], and cache it
            };
        }(this));
    </script>

</body>
<script>
    // ensure both male and female are selected by default (add after body tag so Dom is completely loaded.)
        //updateButtonColors(d3.select("g.button.both"), d3.select("#genderButtons"));

</script>


</html>
